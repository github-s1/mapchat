/*  *  */define(function(require){    "use strict";        var $ = require('jquery'),        _ = require('underscore'),        Backbone = require('backbone'),         AppError = require('appError'),          VMap = require('view/VMap'),         Config = require('config'),                templates = require('templates'),                ThirdPartyMarks = require('model/ThirdPartyMarks').getInstance(),        VAuth = require('view/VAuth');        return VMap.extend({                el      : '#map',        geoObjectCollection: null,                initialize: function(options) {            if(!this.el){                this.$el = $("<section id='map'></section>").insertAfter($("body>header").first());                this.setElement(this.$el);            }//            console.log(this.$el);            VMap.prototype.initialize.call(this, {parent: options.parent, el: this.el});            this.geoObjectCollection = new this.YMapNS.GeoObjectCollection();                        this.createClusterer();            this.setHandlers();        },                setHandlers: function(){            this.YandexMap.events.add('contextmenu', function (e){                console.log(e.get('coords'));                if(!this.selfUser.loggedIn()){                    new VAuth({parent: this, user: this.selfUser});                    return;                }                this.removeMarksFromMap();                // открывает окно выбора типа значка - http://joxi.ru/J2b5znPiY6Enm6                this.parent.model.trigger("changePage", {                    pageName: "markAdding"                });            }, this);                        this.YandexMap.events.add('click', function (e) {                var coords = e.get('coords');                this.trigger("map:click", { coords: coords });            }, this);                        this.YandexMap.events.add('dblclick', function (e) {                var coords = e.get('coords');                this.trigger("map:dblclick", { coords: coords });            }, this);        },                setSelectedMark: function(markId) {            var marks = this.parent.model.marks;            var center = marks.get(markId).getCenter();            this.setCenter(center);        },                removeMarksFromMap: function() {            if(this.geoObjectCollection.getLength() > 0){                this.geoObjectCollection.removeAll();            }            if(this.YandexMap.geoObjects.getLength() > 0){                this.YandexMap.geoObjects.removeAll();            }                        /****************** New  ************************/            var clustererSize = this.clusterer.getGeoObjects().length;            if(clustererSize > 0){                this.clusterer.removeAll();            }            /****************** /New  ************************/        },                getGeoObjectFromMark: function(mark) {            var mapMark = mark.get("mapMark");            if(!mapMark){                Backbone.trigger("logger:warning", new AppError({                    data: mark.toJSON(),                    type: "ScriptError",                    className: "VMapMain",                    methodName: "addMarkToGeoObjectCollection",                    message: "Для значка не создан геообъект"                }));                return false;            }            return mapMark;        },                addMarkToGeoObjectCollection: function(mark) {            var mapMark = this.getGeoObjectFromMark(mark);            if(mapMark){                this.geoObjectCollection.add(mapMark);            }        },                getPointsForEditor: function(firstPoint) {            var delta, zoom = this.YandexMap.getZoom();                        if(zoom < 4){                delta = 6;            }            else if(zoom < 6){                delta = 3;            }            else if(zoom < 7){                delta = 1;            }            else if(zoom < 8){                delta = 0.8;            }            else if(zoom < 10){                delta = 0.3;            }            else if(zoom < 12){                delta = 0.08;            }            else if(zoom < 13){                delta = 0.03;            }            else if(zoom < 14){                delta = 0.015;            }            else if(zoom < 15){                delta = 0.007;            }            else if(zoom < 16){                delta = 0.003;            }            else if(zoom < 17){                delta = 0.002;            }            else if(zoom < 18){                delta = 0.001;            }            else {                delta = 0.0005;            }                        var point2 = [firstPoint[0], firstPoint[1] + delta*2];            return [firstPoint, point2];        },                startEditing: function(client, startPoint) {            this.YandexMap.geoObjects.removeAll();            var points = this.getPointsForEditor(startPoint);                        // Создаем ломаную.            var polyline = new this.YMapNS.Polyline(points, {}, {                // Задаем опции геообъекта.                // Цвет с прозрачностью.                strokeColor: "#ff0000",                // Ширину линии.                strokeWidth: 2,                // Добавляем в контекстное меню новый пункт, позволяющий удалить ломаную.                editorMenuManager: function (items) {                    items.push({                        title: "Завершить рисование",                        onClick: function () {                            polyline.editor.stopEditing();                            client.stopEditing(polyline.geometry.getCoordinates());                        }                    });                    return items;                }            });                        this.YandexMap.geoObjects.add(polyline);            polyline.editor.startEditing();        },                remove: function() {            this.removeMarksFromMap();            this.undelegateEvents();            this.stopListening();            this.destroy();            this.$el.remove();        },                /*************************** New  *********************************/                createClusterer: function() {            this.clusterer = new this.YMapNS.Clusterer({                groupByCoordinates: false,                clusterDisableClickZoom: true,                clusterHideIconOnBalloonOpen: false,                geoObjectHideIconOnBalloonOpen: false            });        },                addMarksToMap: function(marks, changeBounds) {            if (typeof changeBounds == 'undefined') changeBounds = true;            this.removeMarksFromMap();            var geoObjects = [];            //! Сразу добавляем значки из сторонних сервисов            geoObjects = ThirdPartyMarks.getGeoObjects();            if (marks.length > 0) {                marks.forEach(function(mark){                    var markType = mark.getType(),                        mapMark = this.getGeoObjectFromMark(mark);;                    if(mapMark){                        if(markType === "Point"){                            geoObjects.push(mapMark);                        }                        else {                            this.geoObjectCollection.add(mapMark);                        }                    }                }, this);            }                        if (geoObjects.length === 0) return;                        this.clusterer.add(geoObjects);            this.geoObjectCollection.add(this.clusterer);            this.YandexMap.geoObjects.add(this.geoObjectCollection);            // Устанавливаем карте центр и масштаб так, чтобы охватить коллекцию целиком.            if (changeBounds === true) {                this.YandexMap.setBounds(this.geoObjectCollection.getBounds(),{                    checkZoomRange: true                });            }        },        /**         * Добавить на карту значки сторонних сервисов         */        addThirdPartyMarks: function() {            var marks = window.thirdPartyMarks || [];                        marks.forEach(function(item){                //console.log(item);            });        },        showMarkBalloon: function(markId) {            var mapMark = this.findInClusterer(markId);            if(mapMark){                this.showMarkBalloonInClusterer(mapMark);            } else {                mapMark = this.findInGeoObjectCollection(markId);                if(mapMark){                    mapMark.balloon.open();                }            }        },                hideMarkBalloon: function(markId) {            var mapMark = this.findInClusterer(markId);            if(mapMark){                this.hideMarkBalloonInClusterer(mapMark);            }            else {                mapMark = this.findInGeoObjectCollection(markId);                if(mapMark){                    mapMark.balloon.close();                }            }        },                showMarkBalloonInClusterer: function(mapMark){            var mapMarkState = this.clusterer.getObjectState(mapMark);            // Проверяем, находится ли объект в видимой области карты.            if (mapMarkState && mapMarkState.isShown) {                // Если объект попадает в кластер, открываем балун кластера с нужным выбранным объектом.                if (mapMarkState.isClustered) {                    mapMarkState.cluster.state.set('activeObject', mapMark);                    this.clusterer.balloon.open(mapMarkState.cluster);                } else {                    // Если объект не попал в кластер, открываем его собственный балун.                    mapMark.balloon.open();                }            }        },                hideMarkBalloonInClusterer: function(mapMark){            var mapMarkState = this.clusterer.getObjectState(mapMark);            // Проверяем, находится ли объект в видимой области карты.            if (mapMarkState && mapMarkState && mapMarkState.isShown) {                if (mapMarkState.isClustered) {                    this.clusterer.balloon.close(mapMarkState.cluster);                } else {                    mapMark.balloon.close();                }            }        },                findInGeoObjectCollection: function(markId){            markId = parseInt(markId, 10);            var length = this.geoObjectCollection.getLength();            for(var i = 0; i < length; i++){                var id = parseInt(this.geoObjectCollection.get(i).properties.get("id"), 10);                if(markId === id){                    return this.geoObjectCollection.get(i);                }            }            return false;        },                findInClusterer: function(markId){            var geoObjects = this.clusterer.getGeoObjects(),                 length = geoObjects.length;                        markId = parseInt(markId, 10);            for(var i = 0; i < length; i++){                var id = parseInt(geoObjects[i].properties.get("id"), 10);                if(markId === id){                    return geoObjects[i];                }            }            return false;        },                addMyLocation: function(coordinates, setCenter) {            if (typeof setCenter == 'undefined') {                this.zoom = 15;                this.setCenter(coordinates);            }            var geoObject = new this.YMapNS.GeoObject({                    geometry: {                        type: "Point",                        coordinates: coordinates                    }                }, {                    visible: true,                    iconLayout: 'default#image',                    iconImageHref: Config.MarkIconPath + 'my_location.png',                    iconImageSize: [100, 100],                    iconImageOffset: this.getOffsetForMap()                });                            this.YandexMap.geoObjects.add(geoObject);        },                getOffsetForMap: function(){            var width = 100,                height = 100,                 offsetX = Math.ceil(width/2),                 offsetY = Math.ceil(height/2);            return [-offsetX, -offsetY];        },                /*************************** /New  *********************************/    });});