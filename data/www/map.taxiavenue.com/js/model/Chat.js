define([    'jquery',    'backbone',     'config',     'collection/Users',     'collection/Messages'], function($, Backbone, Config, Users, Messages){    "use strict";    return Backbone.Model.extend({        socket: null,        roomId: null,        users: new Users(),        messages: new Messages(),        isActiveConnection: false,        countNewPrivate: false,        initialize: function(options) {            this.selfUser = options.selfUser;     // Текущий пользователь             this.location = options.location;            this.initSocket();            this.listenTo(this.selfUser, 'logged:in', this.join);            this.listenTo(this.selfUser, 'logged:out', this.leave);            this.listenTo(this.location, 'changeRegion', this.changeRoomAfterRegionChange);        },        leave: function(){            if (typeof this.socket !== 'undefined') {                this.socket.emit('leave');                this.trigger("logged:out");            }        },                initSocket: function() {            if(typeof io === 'undefined') return;            this.socket = io.connect(Config.socketUrl, { forceNew: true });            var self = this;            // connect кастомное событие node. (его не надо емитить)            this.socket.on('connect', function(){                if(self.selfUser.loggedIn()){                    self.join();                }                self.socket.on('onJoin', $.proxy(self, "onJoin"));                                /**                 * Полученно новое сообщение в ГОРОДЕ                 */                self.socket.on('message', $.proxy(self, "addMessage"));                                /**                 * Полученно новое ЛИЧНОЕ сообщение                 */                self.socket.on('received_new_private', $.proxy(self, "notifyNewPrivate"));                /**                 * Уведомить всех кто в городе, что добавился новый пользователь                 */                self.socket.on('add_user_in_room', function(res) {                    self.trigger('add_user_in_room', res);                });                self.socket.on('leave_user_from_room', function(res) {                    self.trigger('leave_user_from_room', res);                });            });            this.socket.on('disconnected', function(err){                console.log(err);            });        },        join: function(){            if (typeof this.socket === 'undefined') return;            if(this.selfUser.loggedIn()){                var data = {                    userId: this.selfUser.get("id"),                    city: {                        id      : 'city_' + this.location.region.get('id'),                        name    : this.location.region.get('name_en'),                    }                };                this.socket.emit('join', data);            }        },        /**         * Уведомить пользователя, что пришло новое сообщение (но не отображать)         */        notifyNewPrivate: function(data) {            var room = data.room;            var fromId = data.from;            var toId = data.to;            if (this.selfUser.get("id") != toId) return; // Собщение не тому))            if (this.roomId == room && !$('#chat').hasClass('hide')) return; // Если пользователь находится в этой комнате - обрабатываем socket.on('message'...            //if (this.roomId.indexOf('_') > -1) {                            this.trigger('notify_user', fromId);            //}        },        sendMessage: function(message){            this.socket.emit('message', {                user_id: this.selfUser.get("id"),                content: message,                date_create: Math.floor((new Date().getTime()) / 1000)            }, $.proxy(this, "receiveSelfMessage"));        },                receiveSelfMessage: function(data) {            this.addMessage(data, true);        },                /**         * когда с сервера приходят данные по комнате (городу или личке)         */        onJoin: function(data){            if(data.error) {                return;            }            this.roomId = data.roomId;            this.users.set(data.users);            this.messages.createMessages(data.messages, this.users, this.selfUser.get("id"));            if (typeof data.countNewPrivate !== 'undefined') this.set({countNewPrivate: data.countNewPrivate});            $('#tc_countPrivate').html(data.countNewPrivate);        },        addMessage: function(data, isSelf){            if(data.error) {                return;            }                        // Уведомить в topControl что пришло смс в город            if (typeof isSelf == 'undefined' && ($('#chat').length == 0 || $('#chat').hasClass('hide'))) {                var count = $('#tc_countCity').html();                $('#tc_countCity').html(++count);            }                        this.users.set(data.user);            var user = this.users.get(data.user.id);            this.messages.addMessage({                isSelf: parseInt(this.selfUser.get("id"), 10) === parseInt(data.user.id, 10),                selfUserId: parseInt(this.selfUser.get("id"), 10),                message: data.message,                user: user            });        },                /**         * Получить список переписчиков в личных сообщениях         */        getPrivateList: function(callback) {            this.socket.emit('get_private_list', function(data){                // data = {from_id, count, login}                callback(data);            });        },                /**         * Изменить вид (сообщения в главном окне) чата         */        changeRoom: function(roomId) {            var self = this;            this.socket.emit('change_room', roomId, function(res, listOnline){                self.trigger('room_changed', res, listOnline);            });        },        /**         * Изменение чата после изменения города         */        changeRoomAfterRegionChange: function(region) {            var roomId = region.id;            this.changeRoom('city_' + roomId);        },                getUserInfo: function(user) {            var data = {};            data.id = user.id;            //data.userAvatar = Config.AvatarPath + user.small_photo;            data.userName = (user.name === null) ? user.login : user.name;            data.userProfileLink = Config.baseUrl + "user/" + user.id;            data.isSelf = (user.id === this.selfUser.get('id'));            return data;        }    });});