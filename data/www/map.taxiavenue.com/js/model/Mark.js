/*  *  */define(function(require){    "use strict";    var $ = require('jquery'),         _ = require('underscore'),         Backbone = require('backbone'),        AppError = require('appError'),        Config = require('config'),        templates = require('templates');    var Mark = Backbone.Model.extend({        defaultFoto: "placeholder.jpg",        markBalloonTemplate: _.template(templates.markBalloon),        clusterBalloonTemplate: _.template(templates.clusterBalloon),        defaults: {            audio: null,            id_kind: 0,            kind: null,            id_user: 0,            user: null,            description: "",            address: "",            createDatatime: Math.floor(new Date().getTime() / 1000),            active: "Y",            click_spam: 0,            points: [],            photos: [],            comments: [],            views: 0,            period: "0",            mapMark: null        },        initialize: function(data) {            var photos = [];            if(data.photos && _.isArray(data.photos)){                photos = data.photos;            }            // "Доукомплектовываем" массив "болванками"            for(var i = photos.length; i < 3; i++){                photos.push(this.defaultFoto);            }            this.set("photos", photos);        },        getType: function(){            return this.get('kind').get('type').get('name_en');        },        isDefaultPhoto: function(photo){            return (Config.MarkPhotoPath + this.defaultFoto) === photo;        },        save: function(callback){            $.ajax({                type: "POST",                data: {                    id_kind: this.get("id_kind"),                    createData: this.get("createDatatime"),                    point: this.get("points")                },                url: Config.baseUrlJSON + "mark_json/addMark"            })            .done(function(result){                if(!result){                    return callback(new AppError({                        type: "ServerDataError",                        className: "Mark",                        methodName: "save",                        message: "Не удалось сохранить значок"                    }));                }                var data = eval('(' + result + ')');                callback(null, data.response);            })            .fail(callback);        },        update: function(data, callback){            $.ajax({                type: "POST",                data: {                    id_mark: this.get("id"),                    id_kind: data.id_kind,                    address: data.address,                    description: data.description,                    point: this.get("points"),                    active: this.get("active"),                    period: this.get("period")                },                url: Config.baseUrlJSON + "mark_json/UpdateMark"            })            .done(function(result){                if(!result){                    return callback(new AppError({                        type: "ServerDataError",                        className: "Mark",                        methodName: "update",                        message: "Не удалось обновить данные значка"                    }));                }                var data = eval('(' + result + ')');                callback(null, data.response);            })            .fail(callback);        },                updatePhoto: function(data, callback){            $.ajax({                type: "POST",                data: data,                context: this,                url: Config.baseUrlJSON + "photo_json/AddPhoto",                processData: false,  // tell jQuery not to process the data                contentType: false   // tell jQuery not to set contentType            }).done(function(result){                result = eval('(' + result + ')');                var name = result.response.name,                     position = parseInt(result.response.position, 10);                if(name && !isNaN(position)){                    this.get("photos")[position] = name;                    callback(null, result.response);                }                else {                    callback(AppError({                        data: result,                        className: "Mark",                        type: "ServerDataError",                        methodName: "updatePhoto",                        message: "Сервер вернул некорректные данные"                    }));                }            })            .fail(function(err){                callback(AppError({                    data: data,                    inner: err,                    className: "Mark",                    type: "ServerError",                    methodName: "updatePhoto",                    message: "Не удалось сохранить изображение на сервер"                }));            });        },                checkSetupData: function() {            var length = this.get('points').length,                type = this.get('kind').get('type').get('name_en');            switch(type){                case "Point":                    if(length > 1){                        throw new AppError({                            className: "Mark",                            type: "ServerDataError",                            methodName: "checkSetupData",                            message: "Для типа значка 'Point' не может быть больше 1 точки. ID значка #: " + this.get("id")                        });                    }                break;                case "LineString":                    if(length < 2){                        throw new AppError({                            className: "Mark",                            type: "ServerDataError",                            methodName: "checkSetupData",                            message: "Для типа значка 'LineString' не может быть меньше 2 точек. ID значка #: " + this.get("id")                        });                    }                break;            }        },                belongsToKind: function(id_kind) {            return (id_kind === this.get("id_kind"));        },                belongsToTheme: function(id_theme) {            try {                return (id_theme === this.get("kind").get("theme").get("id"));            }            catch(e){                return false;            }        },        createMapMark: function() {            var type = this.getType();            switch(type){                case "Point":                    return this.createPointMark();                case "LineString":                    return this.createLineMark();            }        },        getClusterBalloonContentBody: function() {            return this.clusterBalloonTemplate({                diffDate: this.getDateDifferenceForMapMark(),                title: this.get('kind').get('name_ru'),                kindLink: this.get('kind').getLink(),                markLink: this.getLink(),                iconSrc: this.getIconSrc(),                description: this.getDescription()            });        },        createPointMark: function() {            var kind = this.get('kind'),                icon = kind.get('icon'),                geoObject = null;            try {                geoObject = new Config.YMapNS.GeoObject({                    geometry: {                        type: "Point",                        coordinates: this.getCoordinates()                    },                    properties: {                        id: this.get('id'),                        diffDate: this.getDateDifferenceForMapMark(),                        link: kind.getLink(),                        hintContent: kind.get('name_ru'),                        description: this.getDescription(),                        clusterCaption: kind.get('name_ru'),                        balloonContentBody: this.getClusterBalloonContentBody()                    }                }, {                    visible: true,                    balloonLayout: this.createBalloonForMark(),                    iconLayout: 'default#image',                    hideIconOnBalloonOpen: false,                    iconImageHref: icon.getSrc(),                    iconImageSize: icon.getSizeForMap(),                    iconImageOffset: icon.getOffsetForMap()                });            }            catch(e){                throw new AppError({                    type: "ScriptError",                    className: "Mark",                    methodName: "createPointMark",                    message: "Ошибка при создании значка. ID значка #: " + this.get("id"),                    inner: e                });            }            return geoObject;        },                createLineMark: function() {            var diff = this.getDateDifferenceForMapMark(),                geoObject = null;            try {                geoObject = new Config.YMapNS.GeoObject({                    geometry: {                        type: "LineString",                        coordinates: this.getCoordinates()                    },                    properties: {                        id: this.get('id'),                        diffDate: diff,                        link: this.get('kind').getLink(),                        title: this.get('kind').get('name_ru'),                        description: this.getDescription()                    }                }, {                    visible: true,                    strokeWidth: 2,                    strokeColor: '#ff0000',                    hideIconOnBalloonOpen: false,                    balloonLayout: this.createBalloonForMark()                });            }            catch(e){                throw new AppError({                    type: "ScriptError",                    className: "Mark",                    methodName: "createLineMark",                    message: "Ошибка при создании значка. ID значка #: " + this.get("id"),                    inner: e                });            }            return geoObject;        },                getCoordinates: function(){            var lat, lng,                points = [],                 models = this.get('points'),                type = this.get('kind').get('type').get('name_en');            switch(type){                case "Point":                    lat = parseFloat(models[0].lat);                    lng = parseFloat(models[0].lng);                    points = [lat, lng];                break;                case "LineString":                    models.forEach(function(model) {                        lat = parseFloat(model.lat);                        lng = parseFloat(model.lng);                        points.push([lat, lng]);                    });                break;            }            return points;        },                createBalloonForMark: function() {            var view = this.markBalloonTemplate({                link: this.getLink(),                title: this.get('kind').get('name_ru'),                diffDate: this.getDateDifferenceForMapMark(),                description: this.getDescription()            });                        var BalloonContentLayout = Config.YMapNS.templateLayoutFactory.createClass(                view, {                // Переопределяем функцию build, чтобы при создании макета начинать                // слушать событие click на кнопке-счетчике.                build: function () {                    // Сначала вызываем метод build родительского класса.                    BalloonContentLayout.superclass.build.call(this);                    // А затем выполняем дополнительные действия.                    $('a.markPage').bind('click', this.showMarkPage);                },                // Аналогично переопределяем функцию clear, чтобы снять                // прослушивание клика при удалении макета с карты.                clear: function () {                    // Выполняем действия в обратном порядке - сначала снимаем слушателя,                    // а потом вызываем метод clear родительского класса.                    $('a.markPage').unbind('click', this.onCounterClick);                    BalloonContentLayout.superclass.clear.call(this);                },                showMarkPage: function (e) {//                    e.preventDefault();                    console.log("Ok");                }            });                        return BalloonContentLayout;        },                getDateDifferenceForMapMark: function() {            var diff = this.getDateDifference();            if(diff < 60){                diff = "(" + diff + "мин)";            }            else {                diff = Math.floor(diff/60);                diff = (diff < 24) ? "(" + diff + "ч)" : null;            }            return diff;        },                getDateDifference: function() {            var t1 = this.get('createDatatime');            var t2 = Math.floor(new Date().getTime() / 1000);            // Результат возвращается в минутах            return Math.floor((t2 - t1)/60);        },                getCenter: function(){            var bounds = this.get("mapMark").geometry.getBounds(),                lat = (bounds[0][0] + bounds[1][0])/2,                lng = (bounds[0][1] + bounds[1][1])/2;            return [lat, lng];        },                hideMapMark: function() {            this.get("mapMark").options.set("visible", false);            if(this.get("mapMark").balloon.isOpen()){                this.get("mapMark").balloon.close();            }            this.trigger("hideMapMark");        },                showMapMark: function() {            this.get("mapMark").options.set("visible", true);            this.trigger("showMapMark");        },                getDescription: function() {            var descr = this.get("description");            if(descr === "" || descr === "Описание отсутствует"){                descr = this.get("address");            }            if(!descr || descr === ""){                descr = "Описание отсутствует";            }            return descr;        },                getLink: function() {            var link = this.get("kind").getLink();                        if (link === false) link = window.location.href;                else link += "/" + this.get("id");            return link;//this.get("kind").getLink() + "/" + this.get("id");        },                getIconSrc: function() {            return Config.MarkIconPath + this.get('kind').get('icon').get('name');        },                toItemOfList: function(city){            var data = this.toJSON();            data.diffDate = this.getDateDifferenceForMapMark();            data.title = data.kind.get('name_ru');            data.kindPageHref = data.kind.getLink(city);            data.markPageHref = this.getLink();            data.icon = this.getIconSrc();            data.description = this.getDescription();            return data;        },                getDateDifferenceForMarkPage: function() {            var diff = Math.floor(this.getDateDifference()/60);            var days = Math.floor(diff/24);            if(days < 1){                diff = diff + "ч назад";            }            else {//                diff = days + "дн., " + diff%24 + "ч назад";                var createDatatime = parseInt(this.get("createDatatime"), 10) * 1000;                diff = Date.create(createDatatime).format("{yyyy}-{MM}-{dd} {hh}:{mm}");            }            return diff;        },                toMarkPage: function(city){            var data = {},                 kind = this.get("kind"),                 period = parseInt(this.get("period"), 10);                        data.id = this.get("id");            data.views = this.get("views");            data.period = period > 0 ? period + " ч" : "Всегда";            data.photos = this.get("photos");            data.audio = this.get('audio');            data.user = this.get('user').toMarkPageView();            data.title = kind.get('name_ru');            data.address = this.get('address');            data.description = this.get('description');            data.anonymous = this.get('anonymous');            data.audioPath = Config.AudioPath;            data.photoPath = Config.MarkPhotoPath;            data.icon = kind.getIconUrl();            data.kindPageHref = kind.getLink(city);            data.avatarPath = Config.AvatarPath;            data.comments = this.get("comments");            data.countOfMarks = kind.get("countOfMarks") - 1;            data.diffDate = this.getDateDifferenceForMarkPage();            data.isGeneralKind = kind.isGeneral();            data.clickSpam = this.get("click_spam");//            console.log(kind.toJSON());            return data;        },                spamIncrement: function(callback) {            $.ajax({                type: "POST",                data: { id_mark: this.get("id") },                url: Config.baseUrlJSON + "mark_json/clickSpam"            })                        .done(function(response){                if (response.res == 'success') {                    //alert('Сохранено');                    callback('save');                }            })            .fail(function(err){                Backbone.trigger("logger:error", new AppError({                        inner: err,                        className: "Mark",                        type: "ServerDataError",                        methodName: "spamIncrement"                    }));            });        },                viewsIncrement: function(){            $.ajax({                type: "POST",                data: { id_mark: this.get("id") },                url: Config.baseUrlJSON + "mark_json/ViewsIncrement"            })            .fail(function(err){                Backbone.trigger("logger:error", new AppError({                        inner: err,                        className: "Mark",                        type: "ServerDataError",                        methodName: "viewsIncrement",                        message: "Не удалось обновить количество просмотров значка"                    }));            });        }            }, {        create: function(data){//            console.log(data);            try {                var mark = new Mark(data);                mark.checkSetupData();                mark.set("mapMark", mark.createMapMark());                return mark;            }            catch(e){                Backbone.trigger("logger:error", new AppError({                    inner: e,                    data: data,                    className: "Mark",                    type: "ServerDataError",                    methodName: "create",                    message: "Не удалось создать объект Mark из полученных данных"                }));                return null;            }        }    });        return Mark;});